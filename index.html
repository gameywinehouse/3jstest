<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Three.js Circle design</title>
<link href="https://fonts.googleapis.com/css2?family=Helvetica:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: 'Helvetica', sans-serif;
}
#canvas-container {
    position: relative;
    width: 100vw;
    height: 100vh;
}
#text-overlay {
    position: absolute;
    bottom: 4vw;
    right: 4vw;
    font-family: 'Helvetica', sans-serif;
    font-size: 8vw;
    font-weight: 600;
    color: #333;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    letter-spacing: 2px;
    z-index: 10;
}
</style>
</head>
<body>
<div id="canvas-container">
<div id="text-overlay">Circle</div>
</div>

npm run build
<!-- Three.js library from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
const camera = new THREE.PerspectiveCamera(
    50, // FOV (degrees)
    window.innerWidth / window.innerHeight, // Aspect ratio
    0.1, // Near clip
    1000 // Far clip
);
camera.position.z = 5;

// RENDERER SETUP
const renderer = new THREE.WebGLRenderer({
    antialias: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('canvas-container').appendChild(renderer.domElement);

// CREATE THE CIRCLE
const circleGeometry = new THREE.CircleGeometry(3, 128);
const circleMaterial = new THREE.MeshBasicMaterial({
    color: 0x000000,
    side: THREE.DoubleSide
});
const circle = new THREE.Mesh(circleGeometry, circleMaterial);
scene.add(circle);

// Function to scale elements based on screen size
function updateSizes() {
    const baseSize = Math.min(window.innerWidth, window.innerHeight) * 0.0008;
    circle.scale.setScalar(baseSize);
    circle.position.x = -window.innerWidth * 0.0008;
    circle.position.y = 0;
}

updateSizes();

// COLOR SWITCHING
let isDark = true;
let isHovering = false;
let hoverStartTime = 0;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onMouseClick(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(circle);
    
    if (intersects.length > 0) {
        isDark = !isDark;
        if (isDark) {
            scene.background.setHex(0xffffff);
            circleMaterial.color.setHex(0x000000);
        } else {
            scene.background.setHex(0x000000);
            circleMaterial.color.setHex(0xffffff);
        }
    }
}

function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(circle);
    
    if (intersects.length > 0) {
        if (!isHovering) {
            isHovering = true;
            hoverStartTime = Date.now();
        }
    } else {
        isHovering = false;
    }
}

function onTouch(event) {
    event.preventDefault();
    const touch = event.touches[0];
    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(circle);
    
    if (intersects.length > 0) {
        isDark = !isDark;
        if (isDark) {
            scene.background.setHex(0xffffff);
            circleMaterial.color.setHex(0x000000);
        } else {
            scene.background.setHex(0x000000);
            circleMaterial.color.setHex(0xffffff);
        }
    }
}

function onTouchMove(event) {
    event.preventDefault();
    const touch = event.touches[0];
    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(circle);
    
    if (intersects.length > 0) {
        if (!isHovering) {
            isHovering = true;
            hoverStartTime = Date.now();
        }
    } else {
        isHovering = false;
    }
}

window.addEventListener('click', onMouseClick);
window.addEventListener('mousemove', onMouseMove);
window.addEventListener('touchstart', onTouch);
window.addEventListener('touchmove', onTouchMove);

// RENDER LOOP
function animate() {
    requestAnimationFrame(animate);

    // Pulse animation using sine function
    const time = Date.now() * 0.001;
    let timeMultiplier = 1;
    
    if (isHovering) {
        const hoverDuration = (Date.now() - hoverStartTime) * 0.0001;
        timeMultiplier = 1 + hoverDuration * 0.5;
    }
    
    const baseSize = Math.min(window.innerWidth, window.innerHeight) * 0.0008;
    const pulseScale = 1 + Math.sin(time * timeMultiplier) * 0.01;
    circle.scale.setScalar(baseSize * pulseScale);

    renderer.render(scene, camera);
}

// Start the animation loop
animate();

window.addEventListener('resize', function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    updateSizes();
});
</script>
</body>
</html>

npm run deploy
